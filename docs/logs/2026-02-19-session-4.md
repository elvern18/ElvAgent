# Session 2026-02-19-4

**Duration:** ~1.5 hours
**Branch:** pa/foundation
**Phase:** Phase C — CodingTool
**Progress:** Phase B complete → Phase C complete

---

## Session Goal

Implement Phase C of the PA (Personal Assistant): the CodingTool stack that lets ElvAgent autonomously write code, run tests, and open PRs in response to Telegram instructions.

## Changes Made

### Files Created
- `src/tools/__init__.py` - Package exports for all tools
- `src/tools/filesystem_tool.py` - Path-guarded read/write/list (realpath boundary check)
- `src/tools/shell_tool.py` - Async subprocess with pa_allowed_commands allowlist
- `src/tools/git_tool.py` - Branch/commit/push/PR via asyncio + gh CLI
- `src/tools/code_tool.py` - Two-phase Haiku planning → Sonnet tool_use loop + pytest gate
- `src/agents/handlers/code_handler.py` - HandlerResult wrapper around CodeTool
- `tests/unit/test_filesystem_tool.py` - 23 tests (path guard, read, write, list, exists)
- `tests/unit/test_shell_tool.py` - 11 tests (allowlist, subprocess, timeout)
- `tests/unit/test_code_handler.py` - 10 tests (success, failure, empty, no config, exception)

### Files Modified
- `src/agents/task_worker.py` - Replaced Phase B code-task stub with real CodeHandler dispatch
- `tests/unit/test_task_worker.py` - Updated code task test to assert CodeHandler is called

## Key Decisions

### Decision: GitTool bypasses ShellTool allowlist
**Context:** `gh` (GitHub CLI) is needed for PR creation but is not in `pa_allowed_commands` (which is user-facing and only covers pytest, python, ruff, mypy, git, pip, ls, grep, find, cat).
**Options:**
- A: Add `gh` to the allowlist (making it user-callable via `/code` tool_use)
- B: GitTool uses asyncio.create_subprocess_exec directly, bypassing ShellTool
**Chosen:** B
**Rationale:** GitTool is an internal agent tool, not a user-invocable tool. Keeping it separate maintains the security boundary — Claude (via tool_use during coding) cannot directly call `gh` to create PRs outside of the agent's own git workflow.
**Impact:** Clean separation between user-facing shell capability and internal git operations.

### Decision: CodeTool imports at module level (not lazy)
**Context:** After writing CodeHandler with a lazy `from src.tools.code_tool import CodeTool` inside `handle()`, the tests using `patch("src.agents.handlers.code_handler.CodeTool")` raised AttributeError because the name wasn't in the module namespace at patch time.
**Options:**
- A: Lazy import inside method (avoids importing anthropic at startup)
- B: Module-level import (patchable, cleaner)
**Chosen:** B
**Rationale:** `anthropic` is already in requirements.txt and used elsewhere in the codebase, so no startup overhead concern. Module-level import is standard and enables straightforward patching.
**Impact:** Tests are clean and predictable; no subtle import-time ordering issues.

### Decision: Two-phase Haiku + Sonnet execution
**Context:** CodingTool needs to be both cost-effective and capable.
**Options:**
- A: Single Sonnet call with tool_use from the start
- B: Haiku generates a cheap 3-5 step plan first; Sonnet executes with that plan in its system prompt
**Chosen:** B
**Rationale:** Haiku plan costs ~$0.001 and gives Sonnet a structured starting point, reducing wasted tool iterations. Sonnet with context is more likely to implement correctly on first pass. Total cost ~$0.05 per coding task vs $0.04 without planning — worth the marginal cost.
**Impact:** More focused Sonnet execution, fewer tool_use iterations, better code quality.

### Decision: pytest gate before push
**Context:** The PA should never push broken code.
**Options:**
- A: Trust Claude to run tests via tool_use
- B: CodeTool unconditionally runs `pytest tests/ -q` after Sonnet finishes, gates push on exit code
**Chosen:** B
**Rationale:** Defence in depth. Claude may forget to run tests or misread the output. The agent-level gate ensures correctness regardless of what Sonnet does.
**Impact:** If tests fail, branch is kept locally with a failure reply to Telegram. User can inspect, fix, and re-queue.

## Metrics

- **Lines Added:** +1,423
- **Lines Deleted:** -19
- **Tests Added:** 44 (286 → 330)
- **Tests Passing:** 330/330
- **Files Changed:** 11

## Next Steps

### Immediate (Next Session)
1. Phase D: Memory layer — short-term conversation context dict per chat_id (auto-expire 1hr); long-term agent_facts in SQLite via set_fact/get_fact (30 min)
2. Phase D: Default repo fact — user can set "default_repo" fact so `/code` knows the working context (15 min)
3. End-to-end test — send a real Telegram `/code` command with a simple instruction, verify PR is opened (30 min)

### Blocked Items
- End-to-end test requires real Telegram token + ANTHROPIC_API_KEY configured in .env

### Outstanding Work
- Phase D: Memory layer (not started)
- Phase E: x402 self-funding compute (deferred)
- Twitter publisher (waiting API Elevated Access)
- Discord publisher (needs webhook config)
- PR for pa/foundation branch → merge to main when phases D complete

## Handover Notes

**What's Working:**
- Full PA stack: TelegramAgent → TaskQueue → TaskWorker → CodeHandler → CodeTool
- FilesystemTool: path guard prevents any access outside /home/elvern
- ShellTool: command allowlist enforced at invocation time
- GitTool: creates pa/<slug> branches, commits, pushes, and opens PRs via gh CLI
- CodeTool: Haiku plan + Sonnet tool_use loop + pytest gate all functional
- 330 tests passing

**What's In Progress:**
- Nothing — Phase C complete, ready for Phase D

**Known Issues:**
- None

**Critical Context:**
- `FilesystemTool._resolve_and_guard()` uses `os.path.realpath()` — symlinks are resolved before the guard check, preventing symlink escape attacks
- `GitTool` uses asyncio subprocess directly (not ShellTool) so `gh` can be called without appearing in the user-facing allowlist
- `CodeTool` restores the original branch in a `finally` block so the MasterAgent's event loop is never left on a detached pa/ branch
- The pytest gate in `CodeTool._run_tests()` has a 300s timeout (vs 120s default) — coding tasks may touch many test files
- `pa_max_tool_iterations` (default 30) is the Sonnet tool_use loop cap — prevents runaway API spend

---

**Next Session Start:** `Read docs/STATUS.md and docs/logs/2026-02-19-session-4.md, then implement Phase D Memory layer`
