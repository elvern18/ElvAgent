"""
Unit tests for newsletter formatters.
"""

import pytest

from src.models.enhanced_newsletter import CategoryMessage, EnhancedNewsletterItem
from src.models.newsletter import Newsletter, NewsletterItem
from src.publishing.formatters.discord_formatter import DiscordFormatter
from src.publishing.formatters.markdown_formatter import MarkdownFormatter
from src.publishing.formatters.telegram_formatter import TelegramFormatter


@pytest.fixture
def sample_items():
    """Sample newsletter items for testing."""
    return [
        NewsletterItem(
            title="Novel LLM Architecture",
            url="https://arxiv.org/abs/2024.12345",
            summary="Researchers propose a new transformer architecture that improves efficiency.",
            category="research",
            source="arxiv",
            relevance_score=9,
        ),
        NewsletterItem(
            title="OpenAI Releases GPT-5",
            url="https://openai.com/gpt5",
            summary="Major update with multimodal capabilities.",
            category="product",
            source="news",
            relevance_score=10,
        ),
        NewsletterItem(
            title="Anthropic Raises $500M",
            url="https://techcrunch.com/funding",
            summary="Series C funding led by major investors.",
            category="funding",
            source="techcrunch",
            relevance_score=8,
        ),
    ]


@pytest.fixture
def sample_newsletter(sample_items):
    """Sample newsletter for testing."""
    return Newsletter(
        date="2026-02-15-10", items=sample_items, summary="Today's top AI updates", item_count=3
    )


@pytest.mark.unit
class TestMarkdownFormatter:
    """Tests for MarkdownFormatter."""

    def test_format_includes_header(self, sample_newsletter):
        """Test that formatted output includes proper header."""
        formatter = MarkdownFormatter()
        result = formatter.format(sample_newsletter)

        assert "# AI Newsletter - 2026-02-15-10" in result
        assert "**Published:** 2026-02-15-10" in result
        assert "**Total Items:** 3" in result

    def test_format_includes_summary(self, sample_newsletter):
        """Test that summary is included when present."""
        formatter = MarkdownFormatter()
        result = formatter.format(sample_newsletter)

        assert "## Summary" in result
        assert "Today's top AI updates" in result

    def test_format_without_summary(self, sample_items):
        """Test formatting when summary is empty."""
        newsletter = Newsletter(
            date="2026-02-15-10",
            items=sample_items,
            summary="",  # Empty summary
            item_count=3,
        )

        formatter = MarkdownFormatter()
        result = formatter.format(newsletter)

        # Should not have summary section
        assert "## Summary" not in result

    def test_format_groups_by_category(self, sample_newsletter):
        """Test that items are grouped by category."""
        formatter = MarkdownFormatter()
        result = formatter.format(sample_newsletter)

        # Check category headers are present
        assert "ðŸ“š Research Papers" in result
        assert "ðŸš€ New Products" in result
        assert "ðŸ’° Funding & M&A" in result

    def test_format_includes_all_items(self, sample_newsletter):
        """Test that all items are included in output."""
        formatter = MarkdownFormatter()
        result = formatter.format(sample_newsletter)

        # Check all titles are present
        assert "Novel LLM Architecture" in result
        assert "OpenAI Releases GPT-5" in result
        assert "Anthropic Raises $500M" in result

        # Check all URLs are present
        assert "https://arxiv.org/abs/2024.12345" in result
        assert "https://openai.com/gpt5" in result
        assert "https://techcrunch.com/funding" in result

    def test_format_item_structure(self, sample_newsletter):
        """Test that individual items have correct structure."""
        formatter = MarkdownFormatter()
        result = formatter.format(sample_newsletter)

        # Check for source and score metadata
        assert "**Source:** Arxiv" in result or "**Source:** arxiv" in result.lower()
        assert "**Score:** 9/10" in result
        assert "**Score:** 10/10" in result

        # Check for read more links
        assert "ðŸ”— [Read more]" in result

    def test_format_footer(self, sample_newsletter):
        """Test that footer is included."""
        formatter = MarkdownFormatter()
        result = formatter.format(sample_newsletter)

        assert "---" in result
        assert "Generated by ElvAgent" in result

    def test_format_empty_newsletter(self):
        """Test formatting empty newsletter."""
        newsletter = Newsletter(date="2026-02-15-10", items=[], item_count=0)

        formatter = MarkdownFormatter()
        result = formatter.format(newsletter)

        assert "# AI Newsletter - 2026-02-15-10" in result
        assert "**Total Items:** 0" in result


@pytest.mark.unit
class TestDiscordFormatter:
    """Tests for DiscordFormatter."""

    def test_format_returns_valid_webhook_payload(self, sample_newsletter):
        """Test that formatter returns valid Discord webhook structure."""
        formatter = DiscordFormatter()
        result = formatter.format(sample_newsletter)

        # Check top-level structure
        assert isinstance(result, dict)
        assert "embeds" in result
        assert "username" in result
        assert "avatar_url" in result

        # Check username
        assert result["username"] == "ElvAgent Newsletter"

        # Check embeds structure
        assert isinstance(result["embeds"], list)
        assert len(result["embeds"]) > 0

    def test_format_main_embed(self, sample_newsletter):
        """Test that main embed has correct structure."""
        formatter = DiscordFormatter()
        result = formatter.format(sample_newsletter)

        main_embed = result["embeds"][0]

        assert "title" in main_embed
        assert "ðŸ¤– AI Newsletter - 2026-02-15-10" in main_embed["title"]
        assert main_embed["description"] == "Today's top AI updates"
        assert main_embed["color"] == 0x5865F2
        assert "footer" in main_embed
        assert "3 items" in main_embed["footer"]["text"]

    def test_format_item_embeds(self, sample_newsletter):
        """Test that item embeds have correct structure."""
        formatter = DiscordFormatter()
        result = formatter.format(sample_newsletter)

        # Should have 4 embeds (1 main + 3 items)
        assert len(result["embeds"]) == 4

        # Check first item embed
        item_embed = result["embeds"][1]
        assert "title" in item_embed
        assert "Novel LLM Architecture" in item_embed["title"]
        assert "url" in item_embed
        assert item_embed["url"] == "https://arxiv.org/abs/2024.12345"
        assert "description" in item_embed
        assert "color" in item_embed
        assert "fields" in item_embed

    def test_format_embed_fields(self, sample_newsletter):
        """Test that embed fields contain correct metadata."""
        formatter = DiscordFormatter()
        result = formatter.format(sample_newsletter)

        item_embed = result["embeds"][1]
        fields = item_embed["fields"]

        # Check field structure
        assert len(fields) == 3

        # Check field names
        field_names = [f["name"] for f in fields]
        assert "Source" in field_names
        assert "Category" in field_names
        assert "Score" in field_names

        # Check inline flags
        for field in fields:
            assert field["inline"] is True

    def test_format_respects_embed_limit(self):
        """Test that formatter respects Discord's embed limit."""
        # Create newsletter with more items than embed limit
        items = [
            NewsletterItem(
                title=f"Item {i}",
                url=f"https://example.com/{i}",
                summary=f"Summary {i}",
                category="research",
                source="test",
                relevance_score=5,
            )
            for i in range(15)  # More than max embeds
        ]

        newsletter = Newsletter(date="2026-02-15-10", items=items, item_count=15)

        formatter = DiscordFormatter()
        result = formatter.format(newsletter)

        # Should have max 10 embeds (1 main + 9 items)
        assert len(result["embeds"]) <= 10

    def test_format_truncates_long_title(self):
        """Test that long titles are truncated."""
        long_title = "A" * 300  # Longer than Discord's 256 limit

        item = NewsletterItem(
            title=long_title,
            url="https://example.com",
            summary="Short summary",
            category="research",
            source="test",
            relevance_score=5,
        )

        newsletter = Newsletter(date="2026-02-15-10", items=[item], item_count=1)

        formatter = DiscordFormatter()
        result = formatter.format(newsletter)

        item_embed = result["embeds"][1]
        # Should be truncated to 256 chars
        assert len(item_embed["title"]) <= 256
        assert item_embed["title"].endswith("...")

    def test_format_truncates_long_description(self):
        """Test that long descriptions are truncated."""
        long_summary = "B" * 2100  # Longer than Discord's 2048 limit

        item = NewsletterItem(
            title="Short title",
            url="https://example.com",
            summary=long_summary,
            category="research",
            source="test",
            relevance_score=5,
        )

        newsletter = Newsletter(date="2026-02-15-10", items=[item], item_count=1)

        formatter = DiscordFormatter()
        result = formatter.format(newsletter)

        item_embed = result["embeds"][1]
        # Should be truncated to 2048 chars
        assert len(item_embed["description"]) <= 2048
        assert item_embed["description"].endswith("...")

    def test_category_colors_assigned(self, sample_newsletter):
        """Test that different categories get different colors."""
        formatter = DiscordFormatter()
        result = formatter.format(sample_newsletter)

        # Get colors from item embeds (skip main embed)
        colors = [embed["color"] for embed in result["embeds"][1:]]

        # Check we have expected category colors
        assert 0x5865F2 in colors  # Research (blue)
        assert 0x57F287 in colors  # Product (green)
        assert 0xFEE75C in colors  # Funding (yellow)

    def test_format_empty_newsletter(self):
        """Test formatting empty newsletter."""
        newsletter = Newsletter(date="2026-02-15-10", items=[], item_count=0)

        formatter = DiscordFormatter()
        result = formatter.format(newsletter)

        # Should still have main embed
        assert len(result["embeds"]) == 1
        assert "0 items" in result["embeds"][0]["footer"]["text"]


@pytest.mark.unit
class TestTelegramFormatterEnhanced:
    """Tests for TelegramFormatter enhanced formatting."""

    def test_format_enhanced_single_category(self, sample_category_messages):
        """Test formatting single category message."""
        formatter = TelegramFormatter()

        # Use only first category
        result = formatter.format_enhanced([sample_category_messages[0]])

        # Verify structure
        assert isinstance(result, list)
        assert len(result) >= 1

        # Verify content
        full_text = "\n".join(result)
        assert "follow for daily AI drops" in full_text

        # Verify category content included
        assert len(full_text) > 100  # Should have substantial content

    def test_format_enhanced_multiple_categories(self, sample_category_messages):
        """Test formatting multiple category messages."""
        formatter = TelegramFormatter()

        result = formatter.format_enhanced(sample_category_messages)

        # Verify structure
        assert isinstance(result, list)
        assert len(result) >= 1

        # Verify all categories included
        full_text = "\n".join(result)
        for _msg in sample_category_messages:
            # Check that some text from each category is present
            # (formatted_text is already included by SocialFormatter)
            assert len(full_text) > 100

    def test_format_enhanced_message_splitting(self):
        """Test that long messages are split at 4096 char limit."""
        formatter = TelegramFormatter()

        # Create a very long category message with paragraph breaks
        # (more realistic than a single continuous string)
        paragraphs = []
        for i in range(50):
            paragraphs.append(f"**Item {i}**\n   This is a long summary that goes on and on. " * 10)

        long_text = "\n\n".join(paragraphs)  # ~5000+ chars with paragraph breaks

        # Create sample enhanced items
        item = NewsletterItem(
            title="Test Item",
            url="https://example.com",
            summary="Summary",
            category="research",
            source="test",
            relevance_score=9,
        )

        enhanced_item = EnhancedNewsletterItem(
            original_item=item,
            viral_headline="ðŸ”¬ test headline",
            takeaway="this is huge â€” test",
            engagement_metrics={},
            enhancement_method="ai",
            enhancement_cost=0.0,
        )

        category_msg = CategoryMessage(
            category="research",
            emoji="ðŸ”¬",
            title="ðŸ”¬ from the labs",
            items=[enhanced_item],
            formatted_text=long_text,
        )

        result = formatter.format_enhanced([category_msg])

        # Should be split into multiple messages
        assert len(result) > 1

        # Each message should be under limit
        for msg in result:
            assert len(msg) <= formatter.MAX_MESSAGE_LENGTH

    def test_format_enhanced_empty_list(self):
        """Test formatting empty category list."""
        formatter = TelegramFormatter()

        result = formatter.format_enhanced([])

        # Should still have header/footer
        assert isinstance(result, list)
        assert len(result) >= 1

        full_text = "\n".join(result)
        assert "follow for daily AI drops" in full_text

    def test_format_enhanced_includes_header_footer(self, sample_category_messages):
        """Test that header and footer are included."""
        formatter = TelegramFormatter()

        result = formatter.format_enhanced(sample_category_messages)
        full_text = "\n".join(result)

        # Check intro line (dynamic, from INTRO_LINES pool)
        from src.publishing.enhancers.voice import INTRO_LINES

        assert any(line in full_text for line in INTRO_LINES)

        # Check footer
        assert "follow for daily AI drops" in full_text

    def test_format_enhanced_preserves_markdown(self, sample_category_messages):
        """Test that markdown formatting from SocialFormatter is preserved."""
        formatter = TelegramFormatter()

        result = formatter.format_enhanced(sample_category_messages)
        full_text = "\n".join(result)

        # Verify markdown links are present (not escaped away)
        assert "[" in full_text and "](" in full_text  # Link markers
        assert "â†’" in full_text  # Arrow prefixes for links
